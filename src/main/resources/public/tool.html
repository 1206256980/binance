<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>å¤šåŠŸèƒ½è®¡ç®—å·¥å…·ç®± - æœ€ç»ˆç¨³å®šå¸ƒå±€</title>
    <style>
        /* --- åŸºç¡€æ ·å¼ --- */
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 20px;
            background-color: #f4f4f9;
            color: #333;
            box-sizing: border-box;
            /* ç¡®ä¿ padding åŒ…å«åœ¨ body å®½åº¦å†… */
        }

        .container {
            width: 100%;
            margin: 0 auto;
            background: white;
            padding: 20px 20px 0 20px;
            /* åº•éƒ¨ä¸ç•™ padding, é—´è·ç”± tools-grid å†³å®š */
            border-radius: 8px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            box-sizing: border-box;
        }

        h1 {
            color: #17a2b8;
            text-align: center;
        }

        /* --- å…³é”®å¸ƒå±€æ ·å¼ï¼šç§»é™¤ gapï¼Œä½¿ç”¨è´Ÿå¤–è¾¹è·æŠµæ¶ˆå†…éƒ¨æ¨¡å—è¾¹è· --- */
        .tools-grid {
            display: flex;
            flex-wrap: wrap;
            margin-left: -10px;
            /* æŠµæ¶ˆå·¦ä¾§é—´è· */
            margin-right: -10px;
            /* æŠµæ¶ˆå³ä¾§é—´è· */
            margin-bottom: 20px;
        }

        /* --- å·¥å…·æ¨¡å—æ ·å¼ï¼šç²¾ç¡®è®¡ç®—å®½åº¦å’Œé—´è· --- */
        .calculator-section {
            /* å…³é”®ä¿®æ”¹ 1: ä½¿ç”¨ margin æ¨¡æ‹Ÿ 10px å·¦å³é—´è·å’Œ 20px ä¸‹æ–¹é—´è· */
            margin-left: 10px;
            margin-right: 10px;
            margin-bottom: 20px;

            /* å…³é”®ä¿®æ”¹ 2: ç¡®ä¿è®¡ç®—åçš„å®½åº¦èƒ½ç¨³å®šå æ® 1/3ï¼Œå¹¶é˜»æ­¢è¢«å‹ç¼© */
            flex: 0 0 calc(33.333333% - 20px);
            /* å‡å» å·¦å³ 10px marginï¼Œå…± 20px */
            min-width: 280px;
            /* è®¾ç½®ä¸€ä¸ªåˆç†çš„æœ€å°å®½åº¦ */

            padding: 15px;
            border: 1px solid #ddd;
            border-radius: 8px;
            background-color: #ffffff;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
            box-sizing: border-box;
        }

        .placeholder {
            border: 1px dashed #ced4da;
            background-color: #f8f9fa;
        }

        /* --- å†…éƒ¨å…ƒç´ æ ·å¼ (ä¿æŒä¸å˜) --- */
        h2 {
            color: #007bff;
            border-left: 5px solid #007bff;
            padding-left: 10px;
            margin-bottom: 15px;
            font-size: 1.2em;
        }

        .input-group {
            margin-bottom: 10px;
        }

        .input-group label {
            display: block;
            margin-bottom: 3px;
            font-weight: bold;
            font-size: 0.9em;
        }

        .input-group input[type="number"] {
            width: 100%;
            padding: 8px;
            border: 1px solid #ccc;
            border-radius: 4px;
            box-sizing: border-box;
        }

        .result {
            margin-top: 15px;
            padding: 10px;
            background-color: #e9ecef;
            border: 1px solid #ced4da;
            border-radius: 4px;
            font-weight: bold;
            min-height: 20px;
            cursor: pointer;
            transition: background-color 0.2s;
        }

        .result:hover {
            background-color: #d1e2f0;
        }

        .result span {
            color: #dc3545;
        }

        .copy-hint {
            font-size: 0.75em;
            color: #6c757d;
            margin-left: 5px;
        }

        /* å¤åˆ¶æˆåŠŸçš„æç¤º */
        #copyMessage {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background-color: #28a745;
            color: white;
            padding: 10px 20px;
            border-radius: 5px;
            z-index: 1000;
            opacity: 0;
            transition: opacity 0.5s ease-in-out;
        }

        .visible {
            opacity: 1 !important;
        }

        /* ä»·æ ¼æé†’å·¥å…·ç‰¹æœ‰æ ·å¼ */
        .alert-table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 10px;
            font-size: 0.85em;
        }

        .alert-table th,
        .alert-table td {
            padding: 6px;
            border: 1px solid #ddd;
            text-align: center;
        }

        .alert-table th {
            background-color: #f8f9fa;
        }

        .alert-btn-del {
            color: white;
            background-color: #dc3545;
            border: none;
            padding: 3px 8px;
            border-radius: 3px;
            cursor: pointer;
        }

        .alert-btn-add {
            width: 100%;
            margin-top: 10px;
            padding: 8px;
            background-color: #28a745;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
        }
    </style>
</head>

<body>

    <div class="container">

        <div id="copyMessage">âœ… å·²å¤åˆ¶åˆ°å‰ªè´´æ¿ï¼</div>

        <div class="tools-grid">

            <div class="calculator-section">
                <h2>1. ğŸ“ˆ ä»·æ ¼ç™¾åˆ†æ¯”å˜åŒ–</h2>
                <p style="font-size: 0.8em; color: #6c757d;">å…¬å¼ï¼š$((ç»“æŸä»· - èµ·å§‹ä»·) / èµ·å§‹ä»·) \times 100\%$</p>

                <div class="input-group">
                    <label for="startPrice">èµ·å§‹ä»·ï¼š</label>
                    <input type="number" id="startPrice" placeholder="å¦‚ 0.4974" oninput="calculatePercentageChange()">
                </div>

                <div class="input-group">
                    <label for="endPrice">ç»“æŸä»·ï¼š</label>
                    <input type="number" id="endPrice" placeholder="å¦‚ 0.5011" oninput="calculatePercentageChange()">
                </div>

                <div class="result" onclick="copyResult('percentageChangeResult')">
                    å˜åŒ–ï¼š<span id="percentageChangeResult"></span>
                    <span class="copy-hint">(ç‚¹å‡»å¤åˆ¶)</span>
                </div>
            </div>

            <div class="calculator-section">
                <h2>2. ğŸ’° ä»·æ ¼ç™¾åˆ†æ¯”è°ƒæ•´</h2>
                <p style="font-size: 0.8em; color: #6c757d;">å…¬å¼ï¼š$ä»·æ ¼ \times (1 + ç™¾åˆ†æ¯”)$</p>
                <p style="font-size: 0.7em; color: #6c757d;">(ç™¾åˆ†æ¯”è¯·æŒ‰æ•´æ•°è¾“å…¥ï¼Œå¦‚ 5 æˆ– -2)</p>

                <div class="input-group">
                    <label for="originalPrice">è¾“å…¥ä»·æ ¼ï¼š</label>
                    <input type="number" id="originalPrice" placeholder="è¯·è¾“å…¥åŸå§‹ä»·æ ¼" oninput="calculateAdjustedPrice()">
                </div>

                <div class="input-group">
                    <label for="percentage">è°ƒæ•´ç™¾åˆ†æ¯” (%)ï¼š</label>
                    <input type="number" id="percentage" placeholder="è¯·è¾“å…¥ç™¾åˆ†æ¯”" oninput="calculateAdjustedPrice()">
                </div>

                <div class="result" onclick="copyResult('adjustedPriceResult')">
                    ç»“æœï¼š<span id="adjustedPriceResult"></span>
                    <span class="copy-hint">(ç‚¹å‡»å¤åˆ¶)</span>
                </div>
            </div>

            <div class="calculator-section">
                <h2>3. ğŸ”” ä»·æ ¼æé†’å·¥å…·</h2>
                <p style="font-size: 0.8em; color: #6c757d;">ä»·æ ¼ç©¿é€é˜ˆå€¼å³é€å¾®ä¿¡æé†’ (1sçº§ç›‘æ§)</p>

                <div style="max-height: 250px; overflow-y: auto;">
                    <table class="alert-table">
                        <thead>
                            <tr>
                                <th>å¸å</th>
                                <th>æé†’æ•°å€¼</th>
                                <th>é¢‘ç‡</th>
                                <th>æ“ä½œ</th>
                            </tr>
                        </thead>
                        <tbody id="alertList">
                            <!-- æé†’é¡¹ç›® -->
                        </tbody>
                    </table>
                </div>

                <button class="alert-btn-add" onclick="addAlertRow()">â• æ·»åŠ æé†’</button>
            </div>

            <div class="calculator-section" style="flex: 0 0 calc(100% - 20px); min-width: 100%;">
                <h2>3. ğŸ“Š é©¬ä¸è¡¥ä»“è®¡ç®—å™¨</h2>
                <p style="font-size: 0.8em; color: #6c757d;">æ”¯æŒå¤šç»„è®¡ç®—ï¼Œæ¯ç»„æœ‰ç‹¬ç«‹çš„èµ·å§‹ä»·å’Œè¡¥ä»“åˆ—è¡¨</p>

                <!-- å…¨å±€ä¿è¯é‡‘è®¾ç½® -->
                <div
                    style="margin-bottom: 20px; padding: 15px; background: #eef7ff; border-radius: 8px; border: 1px solid #b3d7ff;">
                    <label style="font-weight: bold; font-size: 1.1em; color: #0056b3;">ğŸ’° å…¨ä»“é’±åŒ…ä½™é¢ (å…±äº«ä¿è¯é‡‘)ï¼š</label>
                    <input type="number" id="globalWalletBalance" placeholder="è¾“å…¥å…¨ä»“æ€»å¯ç”¨ä½™é¢" step="any"
                        style="padding: 10px; border: 2px solid #007bff; border-radius: 6px; width: 200px; font-size: 1em;"
                        oninput="handleGlobalWalletBalanceInput(this.value)">
                    <p style="font-size: 0.85em; color: #666; margin-top: 8px; margin-bottom: 0;">
                        ğŸ’¡ åœ¨å…¨ä»“æ¨¡å¼ä¸‹ï¼Œæ‰€æœ‰ä»“ä½å…±ç”¨æ­¤ä¿è¯é‡‘ã€‚å¼ºå¹³ä»·ä¼šæ ¹æ®æ­¤ä½™é¢åŠå…¶ä»–ä»“ä½çš„ç›ˆäºè‡ªåŠ¨åŠ¨æ€è®¡ç®—ã€‚
                    </p>
                </div>

                <div id="dcaGroupsContainer">
                    <!-- åŠ¨æ€ç”Ÿæˆçš„è®¡ç®—ç»„ä¼šæ”¾åœ¨è¿™é‡Œ -->
                </div>

                <button onclick="addDCAGroup()"
                    style="margin-top: 15px; padding: 10px 20px; background: #007bff; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 1em;">
                    â• æ–°å¢è®¡ç®—ç»„
                </button>
                <button onclick="refreshMMRCache()"
                    style="margin-top: 15px; margin-left: 10px; padding: 10px 20px; background: #28a745; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 1em;">
                    ğŸ”„ åˆ·æ–° MMR æ•°æ®
                </button>
                <span id="dcaSyncStatus" style="margin-left: 15px; font-size: 0.85em; color: #6c757d;"></span>
            </div>
        </div>
    </div>
    </div>

    <script>
        // ========== é©¬ä¸è¡¥ä»“è®¡ç®—å™¨ - å¤šç»„æ”¯æŒ ==========
        let dcaGroups = []; // å­˜å‚¨æ‰€æœ‰è®¡ç®—ç»„
        let groupIdCounter = 0;
        let globalRowIdCounter = 0;
        let dcaGlobalWalletBalance = ''; // ğŸŒŸ æ–°å¢ï¼šå…¨å±€é’±åŒ…ä½™é¢

        // ========== MMR (ç»´æŒä¿è¯é‡‘ç‡) ç®¡ç† ==========

        // åˆå§‹åŒ– MMR ç¼“å­˜
        async function initMMRCache() {
            const cache = localStorage.getItem('mmr_cache');
            const cacheTimestamp = localStorage.getItem('mmr_cache_timestamp');
            const now = Date.now();

            // ç¼“å­˜24å°æ—¶åè¿‡æœŸ
            if (!cache || !cacheTimestamp || (now - parseInt(cacheTimestamp)) > 86400000) {
                console.log('MMR ç¼“å­˜ä¸ºç©ºæˆ–å·²è¿‡æœŸï¼Œæ­£åœ¨ä»å¸å®‰è·å–...');
                await fetchAllLeverageBrackets();
            } else {
                console.log('MMR ç¼“å­˜å·²åŠ è½½');
            }
        }

        // è·å–æ‰€æœ‰äº¤æ˜“å¯¹çš„æ æ†åˆ†å±‚ä¿¡æ¯
        async function fetchAllLeverageBrackets() {
            try {
                updateSyncStatus('ğŸ”„ æ­£åœ¨è·å– MMR æ•°æ®...', '#007bff');
                // ğŸŒŸ é€šè¿‡åç«¯ä»£ç†è°ƒç”¨ï¼Œé¿å… CORS å’Œè®¤è¯é—®é¢˜
                const response = await fetch('/mmr-data');

                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}`);
                }

                const data = await response.json();

                // æ£€æŸ¥æ˜¯å¦æœ‰é”™è¯¯
                if (data.error) {
                    throw new Error(data.error);
                }

                // è½¬æ¢ä¸º Map æ ¼å¼ï¼šsymbol -> brackets
                const mmrMap = {};
                data.forEach(item => {
                    mmrMap[item.symbol] = item.brackets;
                });

                localStorage.setItem('mmr_cache', JSON.stringify(mmrMap));
                localStorage.setItem('mmr_cache_timestamp', Date.now().toString());

                console.log(`æˆåŠŸç¼“å­˜ ${Object.keys(mmrMap).length} ä¸ªäº¤æ˜“å¯¹çš„ MMR æ•°æ®`);
                updateSyncStatus('âœ… MMR æ•°æ®å·²æ›´æ–°', '#28a745');

                return mmrMap;
            } catch (error) {
                console.error('è·å– MMR æ•°æ®å¤±è´¥:', error);
                updateSyncStatus('âš ï¸ MMR æ•°æ®è·å–å¤±è´¥ï¼Œä½¿ç”¨é»˜è®¤å€¼', '#dc3545');
                return null;
            }
        }

        // è·å–å•ä¸ªäº¤æ˜“å¯¹çš„ MMR ä¿¡æ¯ï¼ˆæ‡’åŠ è½½ï¼‰
        async function getMMRForSymbol(symbol) {
            // å…ˆæ£€æŸ¥ç¼“å­˜
            const cache = JSON.parse(localStorage.getItem('mmr_cache') || '{}');

            if (cache[symbol]) {
                return cache[symbol];
            }

            // å¦‚æœç¼“å­˜ä¸­æ²¡æœ‰ï¼ŒæŒ‰éœ€æ‹‰å–
            try {
                console.log(`æ­£åœ¨è·å– ${symbol} çš„ MMR...`);
                // ğŸŒŸ é€šè¿‡åç«¯ä»£ç†è°ƒç”¨
                const response = await fetch(`/mmr-data?symbol=${symbol}`);

                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}`);
                }

                const data = await response.json();

                // æ£€æŸ¥æ˜¯å¦æœ‰é”™è¯¯
                if (data.error) {
                    throw new Error(data.error);
                }

                if (data && data[0]) {
                    // æ·»åŠ åˆ°ç¼“å­˜
                    cache[symbol] = data[0].brackets;
                    localStorage.setItem('mmr_cache', JSON.stringify(cache));

                    console.log(`æˆåŠŸè·å– ${symbol} çš„ MMR`);
                    return data[0].brackets;
                }
            } catch (error) {
                console.error(`è·å– ${symbol} çš„ MMR å¤±è´¥:`, error);
            }

            return null;
        }

        // æ ¹æ®åä¹‰ä»·å€¼è®¡ç®—å½“å‰é€‚ç”¨çš„ MMR
        function getCurrentMMR(brackets, notionalValue) {
            if (!brackets || brackets.length === 0) {
                return { mmr: 0.004, cum: 0 };
            }

            // æŸ¥æ‰¾é€‚ç”¨çš„å±‚çº§
            for (let bracket of brackets) {
                if (notionalValue >= bracket.notionalFloor &&
                    notionalValue < bracket.notionalCap) {
                    return { mmr: bracket.maintMarginRatio, cum: bracket.cum || 0 };
                }
            }

            // å¦‚æœè¶…è¿‡æ‰€æœ‰å±‚çº§ï¼Œä½¿ç”¨æœ€åä¸€å±‚
            const last = brackets[brackets.length - 1];
            return { mmr: last.maintMarginRatio, cum: last.cum || 0 };
        }

        // æ‰‹åŠ¨åˆ·æ–° MMR ç¼“å­˜
        async function refreshMMRCache() {
            localStorage.removeItem('mmr_cache');
            localStorage.removeItem('mmr_cache_timestamp');
            await fetchAllLeverageBrackets();
            calculateDCA(); // é‡æ–°è®¡ç®—
        }

        // è·å–æ•°å­—çš„å°æ•°ä½æ•°
        function getDecimalPlaces(numStr) {
            if (!numStr || numStr === '') return 4;
            const str = numStr.toString();
            const dotIndex = str.indexOf('.');
            if (dotIndex === -1) return 0;
            return str.length - dotIndex - 1;
        }

        // æ·»åŠ æ–°çš„è®¡ç®—ç»„
        function addDCAGroup() {
            const groupId = groupIdCounter++;
            const group = {
                id: groupId,
                coinName: '',
                basePrice: '',
                side: 'short', // ğŸŒŸ æ”¹ä¸ºé»˜è®¤ï¼šç©ºå• (Short)
                includeInMargin: true, // ğŸŒŸ æ–°å¢ï¼šæ˜¯å¦è®¡å…¥å…¨ä»“ä¿è¯é‡‘
                leverageBrackets: null, // ğŸŒŸ æ–°å¢ï¼šè¯¥å¸ç§çš„æ æ†åˆ†å±‚ä¿¡æ¯
                rows: []
            };
            // é»˜è®¤æ·»åŠ 3è¡Œ
            for (let i = 0; i < 3; i++) {
                group.rows.push({ id: globalRowIdCounter++, rise: '', price: '', position: '' });
            }
            dcaGroups.push(group);
            renderAllGroups();
            saveDCAToStorage();
        }

        // åˆ é™¤è®¡ç®—ç»„
        function removeDCAGroup(groupId) {
            dcaGroups = dcaGroups.filter(g => g.id !== groupId);
            renderAllGroups();
            saveDCAToStorage();
        }

        // æ·»åŠ è¡¥ä»“è¡Œï¼ˆåœ¨æŒ‡å®šè¡Œåæ’å…¥ï¼Œå¦‚æœä¸æŒ‡å®šåˆ™æ·»åŠ åˆ°æœ«å°¾ï¼‰
        function addDCARow(groupId, afterRowId = null) {
            const group = dcaGroups.find(g => g.id === groupId);
            if (group) {
                const newRow = { id: globalRowIdCounter++, rise: '', price: '', position: '' };
                if (afterRowId !== null) {
                    const afterIndex = group.rows.findIndex(r => r.id === afterRowId);
                    if (afterIndex !== -1) {
                        group.rows.splice(afterIndex + 1, 0, newRow);
                    } else {
                        group.rows.push(newRow);
                    }
                } else {
                    group.rows.push(newRow);
                }
                renderGroup(groupId);
                saveDCAToStorage();
            }
        }

        // åˆ é™¤è¡¥ä»“è¡Œ
        function removeDCARow(groupId, rowId) {
            const group = dcaGroups.find(g => g.id === groupId);
            if (group) {
                group.rows = group.rows.filter(r => r.id !== rowId);
                renderGroup(groupId);
                calculateDCA(groupId);
                saveDCAToStorage();
            }
        }

        // æ¸…é™¤å­—æ®µ
        function clearDCAField(groupId, rowId, field) {
            const group = dcaGroups.find(g => g.id === groupId);
            if (group) {
                const row = group.rows.find(r => r.id === rowId);
                if (row) {
                    row[field] = '';
                    renderGroup(groupId);
                    saveDCAToStorage();
                }
            }
        }

        // å¤„ç†å¸åè¾“å…¥
        async function handleCoinNameInput(groupId, value) {
            const group = dcaGroups.find(g => g.id === groupId);
            if (group) {
                group.coinName = value;
                // æ›´æ–°æ ‡é¢˜
                const titleEl = document.getElementById(`groupTitle_${groupId}`);
                if (titleEl) {
                    titleEl.textContent = `ğŸ“ˆ è®¡ç®—ç»„ ${dcaGroups.findIndex(g => g.id === groupId) + 1}${value ? ' - ' + value : ''}`;
                }

                // ğŸŒŸ è‡ªåŠ¨è·å–è¯¥å¸ç§çš„ MMR
                if (value && value.trim() !== '') {
                    const symbol = value.toUpperCase();
                    const brackets = await getMMRForSymbol(symbol);

                    if (brackets) {
                        group.leverageBrackets = brackets;

                        // æ›´æ–° MMR æ˜¾ç¤º
                        updateMMRDisplay(groupId);

                        // é‡æ–°è®¡ç®—ï¼ˆä½¿ç”¨æ–°çš„ MMRï¼‰
                        calculateDCA();
                    }
                }

                saveDCAToStorage();
            }
        }

        // æ›´æ–° MMR æ˜¾ç¤º
        function updateMMRDisplay(groupId) {
            const group = dcaGroups.find(g => g.id === groupId);
            if (!group) return;

            const mmrDisplayEl = document.getElementById(`mmr_display_${groupId}`);
            if (!mmrDisplayEl) return;

            if (!group.leverageBrackets) {
                mmrDisplayEl.textContent = 'MMR: --';
                mmrDisplayEl.style.color = '#666';
                return;
            }

            // è®¡ç®—å½“å‰åä¹‰ä»·å€¼
            const notionalValue = calculateGroupNotionalValue(group);
            const { mmr } = getCurrentMMR(group.leverageBrackets, notionalValue);

            // æŸ¥æ‰¾å½“å‰å±‚çº§
            let tier = 1;
            for (let i = 0; i < group.leverageBrackets.length; i++) {
                const bracket = group.leverageBrackets[i];
                if (notionalValue >= bracket.notionalFloor && notionalValue < bracket.notionalCap) {
                    tier = i + 1;
                    break;
                }
            }

            mmrDisplayEl.textContent = `MMR: ${(mmr * 100).toFixed(2)}% (ç¬¬${tier}å±‚)`;
            mmrDisplayEl.style.color = mmr > 0.005 ? '#dc3545' : '#28a745';
        }

        // è®¡ç®—ç»„çš„åä¹‰ä»·å€¼
        function calculateGroupNotionalValue(group) {
            const basePrice = parseFloat(group.basePrice);
            if (isNaN(basePrice) || basePrice <= 0) return 0;

            let totalValue = 0;
            let prevPrice = null;
            let currentRealPos = 0;

            group.rows.forEach(row => {
                let price = parseFloat(row.price);
                if (row.rise !== '' && !isNaN(parseFloat(row.rise))) {
                    price = basePrice * (1 + parseFloat(row.rise) / 100);
                }
                const position = parseFloat(row.position);

                if (!isNaN(price) && price > 0) {
                    if (prevPrice && currentRealPos > 0) {
                        currentRealPos = currentRealPos * (price / prevPrice);
                    }
                    prevPrice = price;
                }

                if (!isNaN(price) && !isNaN(position) && position > 0) {
                    currentRealPos += position;
                }
            });

            return prevPrice ? currentRealPos * prevPrice : 0;
        }

        // å¤„ç†èµ·å§‹ä»·è¾“å…¥
        function handleBasePriceInput(groupId, value) {
            const group = dcaGroups.find(g => g.id === groupId);
            if (group) {
                group.basePrice = value;
                renderGroup(groupId);
                saveDCAToStorage();
            }
        }

        // å¤„ç†å…¨å±€é’±åŒ…ä½™é¢è¾“å…¥
        function handleGlobalWalletBalanceInput(value) {
            dcaGlobalWalletBalance = value;
            calculateDCA(); // è§¦å‘å…¨é‡é‡ç»˜å¼ºå¹³ä»·
            saveDCAToStorage();
        }

        // å¤„ç†ä¿è¯é‡‘è®¡ç®—å¼€å…³
        function handleMarginToggle(groupId, checked) {
            const group = dcaGroups.find(g => g.id === groupId);
            if (group) {
                group.includeInMargin = checked;
                calculateDCA();
                saveDCAToStorage();
            }
        }

        // å¤„ç†å¤š/ç©ºåˆ‡æ¢
        function handleSideToggle(groupId, side) {
            const group = dcaGroups.find(g => g.id === groupId);
            if (group) {
                group.side = side;
                calculateDCA();
                saveDCAToStorage();
            }
        }

        // å¤„ç†è¡Œè¾“å…¥ (ä¿æŒåŸæœ‰å‡½æ•°ï¼Œä¾›å±€éƒ¨è°ƒç”¨)
        function handleDCAInput(groupId, rowId, field, value) {
            const group = dcaGroups.find(g => g.id === groupId);
            if (!group) return;

            const row = group.rows.find(r => r.id === rowId);
            if (!row) return;

            row[field] = value;
            const basePrice = parseFloat(group.basePrice);
            const priceDecimals = getDecimalPlaces(group.basePrice);

            // äº’æ–¥é€»è¾‘
            if (field === 'rise' && value !== '') {
                row.price = '';
                const priceInput = document.getElementById(`price_${groupId}_${rowId}`);
                if (priceInput && !isNaN(basePrice) && basePrice > 0) {
                    const rise = parseFloat(value);
                    if (!isNaN(rise)) {
                        priceInput.value = (basePrice * (1 + rise / 100)).toFixed(priceDecimals);
                    }
                }
            } else if (field === 'price' && value !== '') {
                row.rise = '';
                const riseInput = document.getElementById(`rise_${groupId}_${rowId}`);
                if (riseInput && !isNaN(basePrice) && basePrice > 0) {
                    const price = parseFloat(value);
                    if (!isNaN(price)) {
                        riseInput.value = (((price - basePrice) / basePrice) * 100).toFixed(2);
                    }
                }
            }

            calculateDCA();
            saveDCAToStorage();
        }

        // ğŸŒŸ æ–°å¢ï¼šä» DOM æš´åŠ›åŒæ­¥æ‰€æœ‰è¾“å…¥åˆ°å†…å­˜å˜é‡
        // é˜²æ­¢å¤šè®¡ç®—ç»„çŠ¶æ€ç”±äºæ¸²æŸ“å»¶è¿Ÿå¯¼è‡´è®¡ç®—ä¸å‡†
        function syncGroupsFromDOM() {
            dcaGroups.forEach(group => {
                // è¯»å–ä¸»è¡¨çš„èµ·å§‹ä»·
                const bpInput = document.getElementById(`basePrice_${group.id}`);
                if (bpInput) group.basePrice = bpInput.value;

                // è¯»å–å¸ç§å (å¦‚æœæœ‰)
                const cnInput = document.getElementById(`coinName_${group.id}`);
                if (cnInput) group.coinName = cnInput.value;

                // è¯»å–æ¯ä¸€è¡Œ
                group.rows.forEach(row => {
                    const riseInput = document.getElementById(`rise_${group.id}_${row.id}`);
                    const priceInput = document.getElementById(`price_${group.id}_${row.id}`);
                    const posInput = document.getElementById(`pos_${group.id}_${row.id}`);

                    if (riseInput) row.rise = riseInput.value;
                    if (priceInput) row.price = priceInput.value;
                    if (posInput) row.position = posInput.value;
                });
            });
            // ä½™é¢
            const balanceInput = document.getElementById('globalWalletBalance');
            if (balanceInput) dcaGlobalWalletBalance = balanceInput.value;
        }

        // æ¸²æŸ“æ‰€æœ‰ç»„
        function renderAllGroups() {
            const container = document.getElementById('dcaGroupsContainer');
            container.innerHTML = '';

            dcaGroups.forEach((group, index) => {
                const groupDiv = document.createElement('div');
                groupDiv.id = `dcaGroup_${group.id}`;
                groupDiv.style.cssText = 'margin-bottom: 25px; padding: 15px; border: 2px solid #007bff; border-radius: 8px; background: #f8f9ff;';

                groupDiv.innerHTML = generateGroupHTML(group, index);
                container.appendChild(groupDiv);

                calculateDCA(group.id);
            });

            // ğŸŒŸ ä¸ºå·²æœ‰å¸åçš„ç»„è‡ªåŠ¨è·å– MMR
            fetchMMRForSavedGroups();
        }

        // ğŸŒŸ æ–°å¢ï¼šä¸ºå·²ä¿å­˜çš„ç»„è·å– MMR
        async function fetchMMRForSavedGroups() {
            for (const group of dcaGroups) {
                if (group.coinName && group.coinName.trim() !== '') {
                    const symbol = group.coinName.toUpperCase();
                    // å¦‚æœè¿˜æ²¡æœ‰æ æ†åˆ†å±‚ä¿¡æ¯ï¼Œåˆ™è·å–
                    if (!group.leverageBrackets) {
                        const brackets = await getMMRForSymbol(symbol);
                        if (brackets) {
                            group.leverageBrackets = brackets;
                        }
                    }
                    // ğŸŒŸ æ— è®ºæ•°æ®æ˜¯åˆšè·å–çš„è¿˜æ˜¯å·²ç»å­˜åœ¨çš„ï¼Œéƒ½å¼ºåˆ¶æ›´æ–°ä¸€æ¬¡ UI æ˜¾ç¤º
                    updateMMRDisplay(group.id);
                }
            }
            // é‡æ–°è®¡ç®—æ‰€æœ‰ç»„
            calculateDCA();
        }

        // æ¸²æŸ“å•ä¸ªç»„
        function renderGroup(groupId) {
            const group = dcaGroups.find(g => g.id === groupId);
            if (!group) return;

            const groupDiv = document.getElementById(`dcaGroup_${groupId}`);
            if (!groupDiv) {
                renderAllGroups();
                return;
            }

            const index = dcaGroups.findIndex(g => g.id === groupId);
            groupDiv.innerHTML = generateGroupHTML(group, index);
            calculateDCA(groupId);
        }

        // ç”Ÿæˆç»„çš„HTML
        function generateGroupHTML(group, index) {
            const basePrice = parseFloat(group.basePrice);
            const priceDecimals = getDecimalPlaces(group.basePrice);


            let rowsHTML = '';
            group.rows.forEach((row, rowIndex) => {

                let displayRise = row.rise;
                let displayPrice = row.price;

                if (!isNaN(basePrice) && basePrice > 0) {
                    if (row.rise !== '' && row.price === '') {
                        const rise = parseFloat(row.rise);
                        if (!isNaN(rise)) {
                            displayPrice = (basePrice * (1 + rise / 100)).toFixed(priceDecimals);
                        }
                    } else if (row.price !== '' && row.rise === '') {
                        const price = parseFloat(row.price);
                        if (!isNaN(price)) {
                            displayRise = (((price - basePrice) / basePrice) * 100).toFixed(2);
                        }
                    }
                }

                rowsHTML += `
                <tr>
                    <td style="padding: 8px; border: 1px solid #ddd; text-align: center;">${rowIndex + 1}</td>
                    <td style="padding: 8px; border: 1px solid #ddd;">
                        <div style="position: relative; display: inline-block;">
                            <input type="number" id="rise_${group.id}_${row.id}" value="${displayRise}" 
                                   placeholder="å¦‚14" step="any" 
                                   style="width: 80px; padding: 8px 22px 8px 8px; border: 1px solid #ccc; border-radius: 4px;"
                                   onchange="handleDCAInput(${group.id}, ${row.id}, 'rise', this.value)">
                            <span onclick="clearDCAField(${group.id}, ${row.id}, 'rise')" 
                                  style="position: absolute; right: 6px; top: 50%; transform: translateY(-50%); cursor: pointer; color: #aaa; font-size: 16px; font-weight: bold;">&times;</span>
                        </div>
                    </td>
                    <td style="padding: 8px; border: 1px solid #ddd;">
                        <div style="position: relative; display: inline-block;">
                            <input type="number" id="price_${group.id}_${row.id}" value="${displayPrice}" 
                                   placeholder="å¦‚1.0097" step="any" 
                                   style="width: 95px; padding: 8px 22px 8px 8px; border: 1px solid #ccc; border-radius: 4px;"
                                   onchange="handleDCAInput(${group.id}, ${row.id}, 'price', this.value)">
                            <span onclick="clearDCAField(${group.id}, ${row.id}, 'price')" 
                                  style="position: absolute; right: 6px; top: 50%; transform: translateY(-50%); cursor: pointer; color: #aaa; font-size: 16px; font-weight: bold;">&times;</span>
                        </div>
                    </td>
                    <td style="padding: 8px; border: 1px solid #ddd;">
                        <div style="position: relative; display: inline-block;">
                            <input type="number" id="pos_${group.id}_${row.id}" value="${row.position}" 
                                   placeholder="å¦‚30" step="any" 
                                   style="width: 70px; padding: 8px 22px 8px 8px; border: 1px solid #ccc; border-radius: 4px;"
                                   onchange="handleDCAInput(${group.id}, ${row.id}, 'position', this.value)">
                            <span onclick="clearDCAField(${group.id}, ${row.id}, 'position')" 
                                  style="position: absolute; right: 6px; top: 50%; transform: translateY(-50%); cursor: pointer; color: #aaa; font-size: 16px; font-weight: bold;">&times;</span>
                        </div>
                    </td>
                    <td style="padding: 8px; border: 1px solid #ddd; text-align: center;" id="cumPos_${group.id}_${row.id}">-</td>
                    <td style="padding: 8px; border: 1px solid #ddd; text-align: center;" id="avgPrice_${group.id}_${row.id}">-</td>
                    <td style="padding: 8px; border: 1px solid #ddd; text-align: center; min-width: 120px;">
                        <div id="liqPrice_${group.id}_${row.id}">-</div>
                        <div id="distLiq_${group.id}_${row.id}" style="font-size: 0.85em; margin-top: 2px; opacity: 0.9;"></div>
                    </td>
                    <td style="padding: 8px; border: 1px solid #ddd; text-align: center;" id="distPrev_${group.id}_${row.id}">-</td>
                    <td style="padding: 8px; border: 1px solid #ddd; text-align: center;" id="currLoss_${group.id}_${row.id}">-</td>
                    <td style="padding: 8px; border: 1px solid #ddd; text-align: center;" id="recovery_${group.id}_${row.id}">-</td>
                    <td style="padding: 8px; border: 1px solid #ddd; text-align: center;">
                        <button onclick="addDCARow(${group.id}, ${row.id})" style="background: #28a745; color: white; border: none; padding: 4px 8px; border-radius: 4px; cursor: pointer; margin-right: 4px;" title="åœ¨ä¸‹æ–¹æ·»åŠ ä¸€è¡Œ">+</button>
                        <button onclick="removeDCARow(${group.id}, ${row.id})" style="background: #dc3545; color: white; border: none; padding: 4px 8px; border-radius: 4px; cursor: pointer;" title="åˆ é™¤æ­¤è¡Œ">Ã—</button>
                    </td>
                </tr>`;
            });

            return `
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                    <div style="display: flex; align-items: center; gap: 15px;">
                        <h3 id="groupTitle_${group.id}" style="margin: 0; color: #007bff;">ğŸ“ˆ è®¡ç®—ç»„ ${index + 1}${group.coinName ? ' - ' + group.coinName : ''} (ç©ºå•)</h3>
                        <label style="display: flex; align-items: center; gap: 5px; font-size: 0.9em; cursor: pointer; background: #f8f9fa; padding: 4px 8px; border-radius: 4px; border: 1px solid #ddd;">
                            <input type="checkbox" ${group.includeInMargin !== false ? 'checked' : ''} 
                                   onchange="handleMarginToggle(${group.id}, this.checked)">
                            è®¡å…¥å…¨ä»“ä¿è¯é‡‘
                        </label>
                    </div>
                    <button onclick="removeDCAGroup(${group.id})" 
                            style="background: #dc3545; color: white; border: none; padding: 6px 15px; border-radius: 4px; cursor: pointer;">
                        ğŸ—‘ï¸ åˆ é™¤æ­¤ç»„
                    </button>
                </div>
                
                <div style="display: flex; gap: 20px; margin-bottom: 15px; align-items: center; flex-wrap: wrap;">
                    <div class="input-group" style="flex: 0 0 auto;">
                        <label style="font-weight: bold; margin-right: 8px;">å¸åï¼š</label>
                        <input type="text" id="coinName_${group.id}" value="${group.coinName || ''}" 
                               placeholder="å¦‚ BTCUSDT" 
                               style="padding: 8px; border: 1px solid #ccc; border-radius: 4px; width: 120px;"
                               onchange="handleCoinNameInput(${group.id}, this.value)">
                        <span id="mmr_display_${group.id}" 
                              style="margin-left: 10px; padding: 4px 10px; background: #e9ecef; border-radius: 4px; font-size: 0.85em; color: #666;">
                            MMR: --
                        </span>
                    </div>
                    <div class="input-group" style="flex: 0 0 auto;">
                        <label style="font-weight: bold; margin-right: 8px;">èµ·å§‹ä»·ï¼š</label>
                        <input type="number" id="basePrice_${group.id}" value="${group.basePrice}" 
                               placeholder="å¦‚ 0.8652" step="any" 
                               style="padding: 8px; border: 1px solid #ccc; border-radius: 4px; width: 150px;"
                               onchange="handleBasePriceInput(${group.id}, this.value)">
                    </div>
                </div>

                <div style="overflow-x: auto;">
                    <table style="width: 100%; border-collapse: collapse; font-size: 0.9em;">
                        <thead>
                            <tr style="background: #e9ecef;">
                                <th style="padding: 8px; border: 1px solid #ddd;">è¡¥ä»“</th>
                                <th style="padding: 8px; border: 1px solid #ddd;">æ¶¨å¹…%</th>
                                <th style="padding: 8px; border: 1px solid #ddd;">ä»·æ ¼</th>
                                <th style="padding: 8px; border: 1px solid #ddd;">ä»“ä½</th>
                                <th style="padding: 8px; border: 1px solid #ddd;">ç´¯è®¡ä»“ä½</th>
                                <th style="padding: 8px; border: 1px solid #ddd;">æˆæœ¬ä»·</th>
                                <th style="padding: 8px; border: 1px solid #ddd; color: #dc3545;">å¼ºå¹³ä»·(è·å¼ºå¹³%)</th>
                                <th style="padding: 8px; border: 1px solid #ddd;">è·ä¸Šæ¬¡%</th>
                                <th style="padding: 8px; border: 1px solid #ddd;">å½“å‰äºæŸ</th>
                                <th style="padding: 8px; border: 1px solid #ddd;">å›æœ¬%</th>
                                <th style="padding: 8px; border: 1px solid #ddd;">æ“ä½œ</th>
                            </tr>
                        </thead>
                        <tbody>
                            ${rowsHTML}
                        </tbody>
                    </table>
                </div>

                <button onclick="addDCARow(${group.id})" 
                        style="margin-top: 10px; padding: 6px 15px; background: #28a745; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 0.9em;">
                    â• æ·»åŠ è¡¥ä»“è¡Œ
                </button>

            `;
        }

        // è®¡ç®—æ‰€æœ‰ç»„çš„DCA
        function calculateDCA() {
            // 1. ğŸŒŸ ç¬¬ä¸€æ­¥ï¼šä» DOM åˆ·æ–°æ‰€æœ‰æ•°æ®
            syncGroupsFromDOM();

            const MMR = 0.004; // ğŸŒŸ ç»´æŒä¿è¯é‡‘ç‡ (0.4%)
            const balanceInput = document.getElementById('globalWalletBalance');
            if (balanceInput) {
                dcaGlobalWalletBalance = balanceInput.value;
            }
            const walletBalance = parseFloat(dcaGlobalWalletBalance) || 0;

            // ç¬¬ä¸€éï¼šæ±‡æ€»æ‰€æœ‰ã€å·²å¼€å¯ã€‘ç»„åœ¨â€œæœ€åä»·æ ¼â€ä¸‹çš„æœ€ç»ˆå¸‚å€¼ã€æ€»æˆæœ¬å’Œ PnL
            const groupStats = dcaGroups.map(group => {
                const basePrice = parseFloat(group.basePrice);
                let gRealPos = 0;
                let gTotalCost = 0;
                let prevPrice = null;

                if (!isNaN(basePrice) && basePrice > 0) {
                    group.rows.forEach((row, index) => {
                        let price = parseFloat(row.price);
                        if (row.rise !== '' && !isNaN(parseFloat(row.rise))) {
                            price = basePrice * (1 + parseFloat(row.rise) / 100);
                        }
                        const position = parseFloat(row.position);

                        if (!isNaN(price) && price > 0) {
                            if (prevPrice && gRealPos > 0) {
                                gRealPos = gRealPos * (price / prevPrice);
                            }
                            prevPrice = price;
                        }
                        if (!isNaN(price) && !isNaN(position) && position > 0) {
                            gRealPos += position;
                            gTotalCost += position;
                        }
                    });
                }

                const isEnabled = group.includeInMargin !== false;
                // ğŸŒŸ è®¡ç®—è¯¥ç»„å½“å‰çš„åä¹‰ä»·å€¼å’Œ MMR
                const notionalValue = gRealPos; // gRealPos å·²ç»æ˜¯ USDT ä»·å€¼
                const { mmr: groupMMR, cum: groupCum } = getCurrentMMR(group.leverageBrackets, notionalValue);

                // åªæœ‰ç©ºå•é€»è¾‘
                const gPnL = isEnabled ? (gTotalCost - gRealPos) : 0;
                // ç»´æŒä¿è¯é‡‘ = åä¹‰ä»·å€¼ * MMR - ç»´æŒä¿è¯é‡‘é€Ÿç®—é¢(CUM)
                const gMM = isEnabled ? (gRealPos * groupMMR - groupCum) : 0;

                return { id: group.id, gRealPos, gTotalCost, lastPrice: prevPrice, isEnabled, gPnL, gMM, groupMMR, groupCum };
            });

            // è´¦æˆ·æ€»ç›ˆäºã€æ€»ç»´æŒä¿è¯é‡‘
            const totalPnL = groupStats.reduce((sum, s) => sum + s.gPnL, 0);
            const totalMM = groupStats.reduce((sum, s) => sum + s.gMM, 0);
            const equity = walletBalance + totalPnL; // ğŸŒŸ è´¦æˆ·å®æ”¶æƒç›Š

            // æ›´æ–°è´¦æˆ·æ±‡æ€»æ˜¾ç¤º
            updateSyncStatus(`è´¦æˆ·æ€»ç›ˆäº: ${totalPnL.toFixed(2)} | è´¦æˆ·æƒç›Š (Equity): ${equity.toFixed(2)} | æ€»ç»´æŒä¿è¯é‡‘: ${totalMM.toFixed(2)}`, totalPnL < 0 ? '#dc3545' : '#28a745');

            // ç¬¬äºŒéï¼šé€è¡Œè®¡ç®—å¹¶æ›´æ–° UI
            dcaGroups.forEach(group => {
                const stats = groupStats.find(s => s.id === group.id);
                const basePrice = parseFloat(group.basePrice);
                if (isNaN(basePrice) || basePrice <= 0) return;

                let currentRealPos = 0;
                let currentTotalCost = 0;
                let prevPrice = null;

                // è®¡ç®—â€œé™¤å»æœ¬ç»„ä»¥å¤–â€çš„å…¶ä»–ç»„çš„æ€»é¢å¤–ä»·å€¼ (OthersBenefit)
                // Liquidation Formula for Short: Equity = Balance + PnL_curr + PnL_others = MM_curr + MM_others
                // (TotalCost_curr - Quantity_curr * P_liq / P_base_at_that_row * P_curr) + Balance + PnL_others = Quantity_curr * P_liq / P_base * P_curr * MMR + MM_others
                // åœ¨æˆ‘ä»¬çš„ç®€åŒ–æ¨¡å‹ä¸­ï¼šQuantity_curr å³ä¸º currentRealPos
                // ç®€åŒ–å…¬å¼ï¼šLiqPrice = (Balance + TotalCost_curr + PnL_others - MM_others) / (Quantity_curr * (1 + MMR))
                const othersBenefit = (stats.isEnabled) ? (totalPnL - stats.gPnL) - (totalMM - stats.gMM) : totalPnL - totalMM;

                group.rows.forEach((row, index) => {
                    let rise = parseFloat(row.rise);
                    let price = parseFloat(row.price);
                    const position = parseFloat(row.position);
                    const priceDecimals = getDecimalPlaces(group.basePrice);

                    if (row.rise !== '' && !isNaN(rise)) {
                        price = basePrice * (1 + rise / 100);
                    }

                    const cumPosEl = document.getElementById(`cumPos_${group.id}_${row.id}`);
                    const avgPriceEl = document.getElementById(`avgPrice_${group.id}_${row.id}`);
                    const liqPriceEl = document.getElementById(`liqPrice_${group.id}_${row.id}`);
                    const distLiqEl = document.getElementById(`distLiq_${group.id}_${row.id}`);
                    const distPrevEl = document.getElementById(`distPrev_${group.id}_${row.id}`);
                    const currLossEl = document.getElementById(`currLoss_${group.id}_${row.id}`);
                    const recoveryEl = document.getElementById(`recovery_${group.id}_${row.id}`);

                    if (!isNaN(price) && price > 0) {
                        const comparePrice = index === 0 ? basePrice : prevPrice;
                        const distPrev = comparePrice ? ((price - comparePrice) / comparePrice) * 100 : 0;
                        if (distPrevEl) distPrevEl.textContent = distPrev.toFixed(2) + '%';
                        if (prevPrice && currentRealPos > 0) {
                            currentRealPos = currentRealPos * (price / prevPrice);
                        }
                        prevPrice = price;
                    }

                    if (!isNaN(price) && !isNaN(position) && position > 0) {
                        currentRealPos += position;
                        currentTotalCost += position;
                    }

                    // å“ªæ€•è¿™ä¸€è¡Œæ²¡å¡« positionï¼Œåªè¦æœ‰ç´¯è®¡æŒä»“ï¼Œå°±æ¸²æŸ“æ•°æ®
                    if (currentRealPos > 0 && !isNaN(price)) {
                        const avgPrice = (currentTotalCost / currentRealPos) * price;
                        const currLossU = (currentTotalCost - currentRealPos);
                        const currLossPercent = (currLossU / currentTotalCost) * 100;

                        if (cumPosEl) cumPosEl.textContent = currentRealPos.toFixed(2);
                        if (avgPriceEl) avgPriceEl.textContent = avgPrice.toFixed(4);
                        if (currLossEl) currLossEl.textContent = currLossU.toFixed(2) + 'ï¼ˆ' + currLossPercent.toFixed(2) + '%ï¼‰';

                        // å›æœ¬ % (Short)
                        if (recoveryEl) {
                            const recPercent = ((price - avgPrice) / price) * 100;
                            recoveryEl.textContent = Math.max(0, recPercent).toFixed(2) + '%';
                        }

                        // å¼ºå¹³ä»·è®¡ç®— (Cross Margin)
                        if (walletBalance > 0 && liqPriceEl && group.includeInMargin !== false) {
                            // ğŸŒŸ ä½¿ç”¨è¯¥ç»„çš„åŠ¨æ€ MMR å’Œé€Ÿç®—é¢(CUM)
                            const currentMMR = stats.groupMMR || 0.004;
                            const currentCum = stats.groupCum || 0;
                            // å…¬å¼: (é’±åŒ…ä½™é¢ + æœ¬ç»„æŒä»“æˆæœ¬ + å…¶ä»–ç»„æƒç›Šè´¡çŒ® + æœ¬ç»„ç»´æŒä¿è¯é‡‘é€Ÿç®—é¢) / (æœ¬ç»„æŒä»“æ•°é‡ * (1 + MMR))
                            const liqPrice = price * (walletBalance + currentTotalCost + othersBenefit + currentCum) / (currentRealPos * (1 + currentMMR));

                            liqPriceEl.textContent = liqPrice.toFixed(priceDecimals);

                            // ğŸŒŸ è®¡ç®—è·ç¦»å¼ºå¹³è¿˜æœ‰å‡ ä¸ªç‚¹
                            if (distLiqEl) {
                                const distLiq = ((liqPrice - price) / price) * 100;
                                distLiqEl.textContent = `(${distLiq.toFixed(2)}%)`;
                                distLiqEl.style.color = liqPriceEl.style.color;
                                distLiqEl.style.fontWeight = liqPriceEl.style.fontWeight;
                            }
                            // é¢œè‰²é€»è¾‘ï¼šå¼ºå¹³ä»·åœ¨ç°ä»·ä¸Šæ–¹ 50% ä»¥å†…æ ‡çº¢
                            if (liqPrice > price && liqPrice < price * 1.5) {
                                liqPriceEl.style.color = '#dc3545';
                                liqPriceEl.style.fontWeight = 'bold';
                            } else {
                                liqPriceEl.style.color = '#28a745';
                                liqPriceEl.style.fontWeight = 'normal';
                            }
                        } else if (liqPriceEl) {
                            liqPriceEl.textContent = '-';
                        }
                    } else {
                        if (cumPosEl) cumPosEl.textContent = '-';
                        if (avgPriceEl) avgPriceEl.textContent = '-';
                        if (currLossEl) currLossEl.textContent = '-';
                        if (recoveryEl) recoveryEl.textContent = '-';
                        if (liqPriceEl) liqPriceEl.textContent = '-';
                        if (distLiqEl) distLiqEl.textContent = '-';
                    }
                });
            });
        }

        // localStorage ç¼“å­˜å’Œåç«¯åŒæ­¥
        let syncTimeout = null;
        function saveDCAToStorage() {
            localStorage.setItem('dca_groups', JSON.stringify(dcaGroups));
            localStorage.setItem('dca_groupIdCounter', groupIdCounter);
            localStorage.setItem('dca_globalRowIdCounter', globalRowIdCounter);
            localStorage.setItem('dca_globalWalletBalance', dcaGlobalWalletBalance);

            // è§¦å‘å…¨é‡è‡ªåŠ¨ä¿å­˜åŒæ­¥
            debounceSyncToBackend();
        }

        function debounceSyncToBackend() {
            if (syncTimeout) clearTimeout(syncTimeout);
            updateSyncStatus('æ­£åœ¨è¾“å…¥...');
            syncTimeout = setTimeout(() => {
                syncToBackend();
            }, 1000); // åœæ­¢è¾“å…¥ 1 ç§’ååŒæ­¥
        }

        function updateSyncStatus(text, color = '#6c757d') {
            const el = document.getElementById('dcaSyncStatus');
            if (el) {
                el.textContent = text;
                el.style.color = color;
            }
        }

        async function syncToBackend() {
            if (dcaGroups.length === 0) {
                console.log('æ£€æµ‹åˆ°æ•°æ®ä¸ºç©ºï¼Œè·³è¿‡åŒæ­¥ä»¥åŒæ­¥ä¿æŠ¤æœåŠ¡å™¨æ•°æ®');
                return;
            }
            if (syncTimeout) clearTimeout(syncTimeout);
            updateSyncStatus('ğŸ”„ æ­£åœ¨åŒæ­¥åˆ°æœåŠ¡å™¨...');
            const data = {
                groups: dcaGroups,
                groupIdCounter: groupIdCounter,
                globalRowIdCounter: globalRowIdCounter,
                globalWalletBalance: dcaGlobalWalletBalance
            };
            try {
                const response = await fetch('/dca-settings', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(data)
                });
                if (response.ok) {
                    console.log('DCA é…ç½®å·²å…¨é‡åŒæ­¥åˆ°åç«¯');
                    updateSyncStatus('âœ… å·²åŒæ­¥åˆ°æœåŠ¡å™¨', '#28a745');
                } else {
                    updateSyncStatus('âŒ åŒæ­¥å¤±è´¥', '#dc3545');
                }
            } catch (err) {
                console.error('åŒæ­¥åˆ°åç«¯å¤±è´¥:', err);
                updateSyncStatus('âš ï¸ ç½‘ç»œé”™è¯¯', '#dc3545');
            }
        }

        async function loadDCAFromStorage() {
            // 1. ä¼˜å…ˆå°è¯•ä»åç«¯åŠ è½½
            try {
                const response = await fetch('/dca-settings');
                if (response.ok) {
                    const data = await response.json();
                    if (data) {
                        dcaGroups = (data.groups || []).map(g => ({ ...g, side: g.side || 'short' }));
                        groupIdCounter = data.groupIdCounter || 0;
                        globalRowIdCounter = data.globalRowIdCounter || 0;
                        dcaGlobalWalletBalance = data.globalWalletBalance || '';

                        if (dcaGroups.length > 0) {
                            // åŒæ­¥ UI ä¸Šçš„å…¨å±€è¾“å…¥æ¡†
                            document.getElementById('globalWalletBalance').value = dcaGlobalWalletBalance;
                            renderAllGroups();
                            console.log('å·²ä»åç«¯åŠ è½½ DCA é…ç½®');
                            return;
                        }
                    }
                }
            } catch (err) {
                console.error('ä»åç«¯åŠ è½½å¤±è´¥ï¼Œå°†å°è¯•æœ¬åœ°ç¼“å­˜:', err);
            }

            // 2. å¤‡é€‰æ–¹æ¡ˆï¼šä» localStorage åŠ è½½
            const savedGroups = localStorage.getItem('dca_groups');
            const savedGroupCounter = localStorage.getItem('dca_groupIdCounter');
            const savedRowCounter = localStorage.getItem('dca_globalRowIdCounter');
            const savedGlobalBalance = localStorage.getItem('dca_globalWalletBalance');

            if (savedGroups) {
                dcaGroups = JSON.parse(savedGroups).map(g => ({ ...g, side: g.side || 'short' }));
            }
            if (savedGroupCounter) {
                groupIdCounter = parseInt(savedGroupCounter);
            }
            if (savedRowCounter) {
                globalRowIdCounter = parseInt(savedRowCounter);
            }
            if (savedGlobalBalance) {
                dcaGlobalWalletBalance = savedGlobalBalance;
                document.getElementById('globalWalletBalance').value = dcaGlobalWalletBalance;
            }

            if (dcaGroups.length === 0) {
                // æ²¡æœ‰ç¼“å­˜æ•°æ®ï¼Œæ·»åŠ é»˜è®¤ 1 ä¸ªç»„
                addDCAGroup();
            } else {
                renderAllGroups();
            }
        }

        // åˆå§‹åŒ–
        loadDCAFromStorage();

        function calculatePercentageChange() {
            const startPrice = parseFloat(document.getElementById('startPrice').value);
            const endPrice = parseFloat(document.getElementById('endPrice').value);
            const resultElement = document.getElementById('percentageChangeResult');

            if (isNaN(startPrice) || isNaN(endPrice) || startPrice === 0) {
                resultElement.textContent = 'è¯·æ£€æŸ¥è¾“å…¥æˆ–èµ·å§‹ä»·ä¸èƒ½ä¸º 0';
                return;
            }

            const change = endPrice - startPrice;
            const percentageChange = (change / startPrice) * 100;

            resultElement.textContent = percentageChange.toFixed(4) + '%';
        }

        function calculateAdjustedPrice() {
            const originalPrice = parseFloat(document.getElementById('originalPrice').value);
            const percentage = parseFloat(document.getElementById('percentage').value);
            const resultElement = document.getElementById('adjustedPriceResult');

            if (isNaN(originalPrice) || isNaN(percentage)) {
                resultElement.textContent = 'è¯·æ£€æŸ¥è¾“å…¥';
                return;
            }

            const factor = 1 + (percentage / 100);

            const adjustedPrice = originalPrice * factor;

            resultElement.textContent = adjustedPrice.toFixed(8);
        }

        function copyResult(spanId) {
            const resultSpan = document.getElementById(spanId);
            let textToCopy = resultSpan.textContent;

            if (!textToCopy || textToCopy.includes('æ£€æŸ¥è¾“å…¥') || textToCopy.includes('Â¥')) {
                textToCopy = textToCopy.replace('Â¥', '').trim();
            }

            if (!textToCopy) return;

            navigator.clipboard.writeText(textToCopy).then(() => {
                showCopyMessage();
            }).catch(err => {
                console.error('å¤åˆ¶å¤±è´¥:', err);
                alert('å¤åˆ¶å¤±è´¥ï¼Œè¯·æ‰‹åŠ¨å¤åˆ¶ï¼š' + textToCopy);
            });
        }

        function showCopyMessage() {
            const message = document.getElementById('copyMessage');
            message.classList.add('visible');

            setTimeout(() => {
                message.classList.remove('visible');
            }, 2000);
        }

        calculatePercentageChange();
        calculateAdjustedPrice();

        // ğŸŒŸ åˆå§‹åŒ– MMR ç¼“å­˜
        initMMRCache();

        // ------------------- ä»·æ ¼æé†’å·¥å…·é€»è¾‘ -------------------
        let priceAlerts = [];

        async function loadPriceAlerts() {
            try {
                const res = await fetch('/price-alerts');
                priceAlerts = await res.json();
                renderPriceAlerts();
            } catch (e) {
                console.error('åŠ è½½ä»·æ ¼æé†’å¤±è´¥', e);
            }
        }

        function renderPriceAlerts() {
            const tbody = document.getElementById('alertList');
            tbody.innerHTML = '';
            priceAlerts.forEach((alert, index) => {
                const tr = document.createElement('tr');
                tr.innerHTML = `
                    <td><input type="text" value="${alert.symbol}" style="width: 70px;" onchange="updateAlert(${index}, 'symbol', this.value)"></td>
                    <td><input type="number" value="${alert.targetPrice}" style="width: 70px;" onchange="updateAlert(${index}, 'targetPrice', this.value)"></td>
                    <td>
                        <select onchange="updateAlert(${index}, 'frequency', this.value)" style="width: 60px;">
                            <option value="once" ${alert.frequency === 'once' ? 'selected' : ''}>ä¸€æ¬¡</option>
                            <option value="continuous" ${alert.frequency === 'continuous' ? 'selected' : ''}>æŒç»­</option>
                        </select>
                    </td>
                    <td><button class="alert-btn-del" onclick="removeAlert(${index})">åˆ </button></td>
                `;
                tbody.appendChild(tr);
            });
        }

        async function updateAlert(index, field, value) {
            if (field === 'targetPrice') value = parseFloat(value);
            if (field === 'symbol') value = value.toUpperCase();
            priceAlerts[index][field] = value;
            // å¦‚æœä¿®æ”¹äº†ç›®æ ‡ä»·æˆ–å¸åï¼Œé‡ç½®è§¦å‘çŠ¶æ€
            if (field === 'targetPrice' || field === 'symbol') {
                priceAlerts[index].isTriggered = false;
            }
            await syncPriceAlerts();
        }

        async function addAlertRow() {
            priceAlerts.push({
                symbol: 'BTCUSDT',
                targetPrice: 0,
                type: 'price_reached',
                frequency: 'once',
                isTriggered: false
            });
            renderPriceAlerts();
            await syncPriceAlerts();
        }

        async function removeAlert(index) {
            priceAlerts.splice(index, 1);
            renderPriceAlerts();
            await syncPriceAlerts();
        }

        async function syncPriceAlerts() {
            try {
                await fetch('/price-alerts', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(priceAlerts)
                });
                showSettingsSyncMessage('æé†’è®¾ç½®å·²åŒæ­¥è‡³æœåŠ¡ç«¯');
            } catch (e) {
                console.error('åŒæ­¥ä»·æ ¼æé†’å¤±è´¥', e);
            }
        }

        function showSettingsSyncMessage(msg) {
            const message = document.getElementById('copyMessage');
            const originalText = message.textContent;
            message.textContent = 'âœ… ' + msg;
            message.classList.add('visible');
            setTimeout(() => {
                message.classList.remove('visible');
                setTimeout(() => { message.textContent = originalText; }, 500);
            }, 2000);
        }

        // åˆå§‹åŒ–åŠ è½½
        loadPriceAlerts();

    </script>

</body>

</html>